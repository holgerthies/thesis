%!TEX root = ../../thesis.tex
\section{Exact Real Arithmetic}\label{sec:exact real arithmetic}
	Using interval arithmetic or arbitrary precision arithmetic, 
	the precision is set in the beginning and rounding and truncation errors still accumulate.
	The result obtained in the end may still not have sufficient precision.

	In contrast, the goal of exact real arithmetic is to perform compuations on real numbers without 
	accumulating errors.
  
  On demand a number can be printed up to any desired precision. 
	More precicely, the user does not specify the precision the numbers are represented with in the beginning,
	but gives a desired precision \textbf{for the answer} of the computation.
  
  The implementation has to take care of the steps necessary to generate the
  solution with the desired precision.
  For the user, it should seem like real numbers are manipulated exactly.

	There are several approaches to exact real arithmetic.
	Some of them are
  \begin{enumerate}
     \item Signed-digit Streams: A real number is represented as an infinite
       string stream. This is very close to the definition with type-2
       machines.
     \item Continued Fractions: A real number is represented by its continued
       fraction representation. Rational numbers have a finite representation,
       while irrational numbers have an infinite representation.
     \item Directed Acyclic Graphs (DAGs): A real number is given by an
       algorithm that computes an approximation to the number with a desired
       error bound. Arithmetic expressions are expressed as graphs with real
       number leaves.
  \end{enumerate}
  The implementations in this thesis follow a form of the DAG approach, thus
  that is the only one that will be described in more detail.
	\subsection{DAGs}
  \begin{figure}[h]
      \centering
      \begin{tikzpicture}[->,shorten >=1pt,auto,node distance=3cm,
  thick,main node/.style={circle,fill=blue!20,draw,font=\sffamily\bfseries}]

  \node[main node] (1) {$+$};
  \node[main node] (2) [below left of=1] {$\sqrt{}$};
  \node[main node] (6) [below of=2] {$2$};
  \node[main node] (3) [below right of=1] {*};
  \node[main node] (4) [below left of=3] {5};
  \node[main node] (5) [below right of=3] {3};

  \path[every node/.style={font=\sffamily\small}]
  (1) edge (2)
  (2) edge (6)
  (1) edge (3)
  (3) edge (4)
  (3) edge (5);
\end{tikzpicture}
\caption{The DAG representation for the expression $\sqrt 2+(2 + 5*3)$}
    \end{figure}
		An arithmetic expression over real numbers can be expressed by a directed acyclic graph (DAG)
		where the leaf nodes are real numbers and the inner nodes are operations on real numbers.
		
    The inner nodes contain the information how precise the inputs to the
    operation have to be, to guarantee a given output precision.
    Thus, the needed precision can be propagated down to the leaf nodes, and
    the algorithms to approximate the real numbers can be invoked.

	  The term evaluating is used to describe the process of getting an approximation
    to the real number represented by a DAG with a desired output  precision.

		There are essentially two ways to evaluate a DAG:
		\begin{enumerate}
			\item \textbf{Top-down evaluation} means, that the desired precision is computed from the top node down to the leaves.
			That is, a node contains the information, how precise he needs the input given by its children to deliver the output with the necessary precision and requests its children to provide it.  
			\item \textbf{Bottom-up evaluation} means, that the computation is started with a fixed precision in the leaf nodes 
			and it is kept track of the errors (e.g. by using interval arithmetic). 
			If in the end, the error bound is too large, the computation is restarted with a higher precision. 
		\end{enumerate}
    \begin{figure}
      \centering
      \begin{tikzpicture}[->,shorten >=1pt,auto,node distance=3cm,
  thick,main node/.style={circle,fill=blue!20,draw,font=\sffamily\bfseries}]

  \node[main node] (1) {$+$};
  \node[main node] (2) [below left of=1] {$x_0$};
  \node[main node] (3) [below right of=1] {$x_1$};
  \node[main node] (4) [above right of=1] {$+$};
  \node[main node] (5) [below right of=4] {$x_{n-1}$};
  \node[main node] (6) [above right of=4] {$+$};
  \node[main node] (7) [below right of=6] {$x_n$};
  \path[every node/.style={font=\sffamily\small}]
  (1) edge (2)
  (1) edge (3)
  (4) edge (5)
  (6) edge (4)
  (6) edge (7);
  \path[every node/.style={font=\sffamily\small}]
  (4) edge (1) [dashed] ;
\end{tikzpicture}
\caption{The DAG created when the expression $\sum_{i=0}^n x_i$ is computed
iteratively}\label{fig:sum dag}
\end{figure}
		While the top-down approach seems to evade unnecessary recomputations, it
    usually largely over-estimates the needed precision.
    For example, to compute additions of two numbers up to precision $2^{-n}$
    it suffices to have the inputs with precision $2^{-(n+1)}$.
    If for example the sum $x := \sum_{i=0}^(1000) x_i$ is computed iteratively (e.g. in a
    for-loop), a DAG as in Figure \ref{fig:sum dag} will be created. 
    Thus, $x_0$ has to be computed with precision $2^{-(n+1000)}$ while actually
    computing all input values with error less than $2^{-(n+10)}$ would 
    suffice to guarantee error of the sum of less than $2^{-n}$.

    In general, saving the DAG representation needs lots of memory. 
    Especially evaluating arithmetic operations in loops that are executed many
    times, will quickly exceed a computer's main memory.
    The pure DAG approach is therefore not applicable for many more complicated
    numerical algorithms.
